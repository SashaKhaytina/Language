// Сейчас здесь как будто имена функций могут использоваться как просто переменные. 
// на переменных можно сделать СПИСОК
// а можно просто сказать, что будет "неопределенное поведение  :)"


Chain_Func   ::= { Created_Func ';' }*




Created_Func ::= 'func' Var '(' Args ')' '{' Chain  Return'}'   // Объявление

Args         ::= Var { ',' Var }*

Return       ::= 'return ' {   | E } ';'






If           ::= 'if' '(' Compare ')' '{' Chain '}'  // ненул посл присваиваний
                                                     // там не E, а "сравнение" должно быть
While        ::= 'while' '(' Compare ')' '{' Chain '}'
    
Assigm       ::= Var '=' E

IO           ::= { 'input' | 'output' } Var
    
Op           ::= If ';' | While ';' | Assigm ';' | IO ';'
    
Chain        ::= { Op }+
    
Compare      ::= E ['==', '<', '>', '<=', '>='] E    // тут еще надо проверять на то, что все переменные должны быть старыми. Но тут (в E) это же фиг проверишь. (будем считать не обЪявленные - 0)                  // не только ==
    
    
    
G            ::= Chain_Func 'MAIN' Chain '$'
E            ::= T { ['+', '-'] T }*
T            ::= Pow { ['*', '/'] P }*
Pow          ::= Heav_op { ['^'] Heav_op}*
    
Heav_op      ::= '(' E ')' | Func | My_Func | Var | Num
    
Func         ::= { ['a' -'z']+ } '(' E ')' 

My_Func      ::=  Var '(' { } | E { ',' E }* ')'  // ПРИЧЕМ они все должны уже существовать
    
    
Var          ::= ['a' -'z']+
Num          ::= ['0' -'9']+